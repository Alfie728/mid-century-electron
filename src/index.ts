import { app, BrowserWindow, desktopCapturer, dialog, ipcMain } from "electron";
import { inputService } from "./main/inputService";
import iohookMacos from "iohook-macos";
import { Action } from "./main/types";
import type { AccessibilityPermissionsResult } from "iohook-macos";
import { promises as fs } from "fs";
import path from "path";
import { spawn } from "child_process";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

// Store main window reference for IPC
let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();

  // Clean up reference when window is closed
  mainWindow.on("closed", () => {
    mainWindow = null;
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
ipcMain.handle("getSources", async () => {
  return await desktopCapturer.getSources({ types: ["screen"] });
});

ipcMain.handle("showSaveDialog", async () => {
  return await dialog.showSaveDialog({
    buttonLabel: "Save video",
    defaultPath: `vid-${Date.now()}.webm`,
  });
});

ipcMain.handle("showSaveExportDialog", async (_event, defaultName?: string) => {
  return await dialog.showSaveDialog({
    buttonLabel: "Save export",
    defaultPath: defaultName || `session-${Date.now()}.zip`,
    filters: [{ name: "Zip", extensions: ["zip"] }],
  });
});

ipcMain.handle("getOperatingSystem", () => {
  return process.platform;
});

type PersistScreenshotPayload = {
  sessionId: string;
  actionId: string;
  phase: "before" | "during" | "after";
  mimeType: string;
  wallClockCapturedAt: number;
  streamTimestampMs?: number;
  captureLatencyMs?: number;
  relativeTimeMs?: number;
  bytes: ArrayBuffer;
};

type PersistScreenshotResult = {
  screenshotId: string;
  screenshotRef: string;
  filePath: string;
};

function safePathSegment(value: string) {
  return value.replace(/[^a-zA-Z0-9._-]+/g, "_");
}

function extensionForMimeType(mimeType: string) {
  switch (mimeType) {
    case "image/webp":
      return "webp";
    case "image/png":
      return "png";
    default:
      return "bin";
  }
}

async function writeFileAtomic(filePath: string, data: Uint8Array) {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
  const tempPath = `${filePath}.tmp-${process.pid}-${Date.now()}`;
  await fs.writeFile(tempPath, data);
  await fs.rename(tempPath, filePath);
}

type PersistVideoPayload = {
  sessionId: string;
  mimeType: string;
  wallClockCapturedAt: number;
  bytes: ArrayBuffer;
};

type PersistVideoResult = {
  videoRef: string;
  filePath: string;
  mimeType: string;
};

function extensionForVideoMimeType(mimeType: string) {
  if (mimeType.includes("webm")) return "webm";
  if (mimeType.includes("mp4")) return "mp4";
  return "bin";
}

ipcMain.handle(
  "persistVideo",
  async (_event, payload: PersistVideoPayload): Promise<PersistVideoResult> => {
    const { sessionId, mimeType, wallClockCapturedAt, bytes } = payload;
    if (!sessionId) throw new Error("persistVideo: sessionId is required");
    if (!mimeType) throw new Error("persistVideo: mimeType is required");

    const sessionSegment = safePathSegment(sessionId);
    const ext = extensionForVideoMimeType(mimeType);
    const filename = `recording-${wallClockCapturedAt}.${ext}`;

    const baseDir = app.getPath("userData");
    const videoDir = path.join(baseDir, "sessions", sessionSegment, "video");
    const filePath = path.join(videoDir, filename);

    const data = new Uint8Array(bytes);
    await writeFileAtomic(filePath, data);

    return {
      videoRef: `video/${filename}`,
      filePath,
      mimeType,
    };
  },
);

type ScreenshotExportMeta = {
  screenshotId: string;
  screenshotRef: string;
  actionId: string;
  phase: "before" | "during" | "after";
  mimeType: string;
  width: number;
  height: number;
  wallClockCapturedAt: number;
  streamTimestampMs?: number;
  captureLatencyMs: number;
};

type ExportSessionBundlePayload = {
  sessionId: string;
  createdAt: number;
  endedAt: number;
  actions: Action[];
  screenshots: ScreenshotExportMeta[];
  video: {
    videoRef: string;
    mimeType: string;
  };
  zipPath: string;
};

function runZip(cwd: string, zipPath: string, args: string[]) {
  return new Promise<void>((resolve, reject) => {
    const child = spawn("zip", ["-r", zipPath, ...args], { cwd });
    let stderr = "";
    child.stderr.on("data", (chunk) => {
      stderr += String(chunk);
    });
    child.on("error", (err) => reject(err));
    child.on("close", (code) => {
      if (code === 0) resolve();
      else reject(new Error(stderr || `zip exited with code ${code}`));
    });
  });
}

ipcMain.handle(
  "exportSessionBundle",
  async (_event, payload: ExportSessionBundlePayload): Promise<{ zipPath: string }> => {
    const { sessionId, zipPath } = payload;
    if (!sessionId) throw new Error("exportSessionBundle: sessionId is required");
    if (!zipPath) throw new Error("exportSessionBundle: zipPath is required");

    const sessionSegment = safePathSegment(sessionId);
    const baseDir = app.getPath("userData");
    const sessionDir = path.join(baseDir, "sessions", sessionSegment);

    await fs.mkdir(path.join(sessionDir, "screenshots"), { recursive: true });
    await fs.mkdir(path.join(sessionDir, "video"), { recursive: true });

    const actionsPath = path.join(sessionDir, "actions.json");
    await fs.mkdir(sessionDir, { recursive: true });
    await fs.writeFile(actionsPath, JSON.stringify(payload, null, 2), "utf8");

    await runZip(sessionDir, zipPath, ["actions.json", "video", "screenshots"]);
    return { zipPath };
  },
);

ipcMain.handle(
  "persistScreenshot",
  async (_event, payload: PersistScreenshotPayload): Promise<PersistScreenshotResult> => {
    const {
      sessionId,
      actionId,
      phase,
      mimeType,
      wallClockCapturedAt,
      relativeTimeMs,
      bytes,
    } = payload;

    if (!sessionId) throw new Error("persistScreenshot: sessionId is required");
    if (!actionId) throw new Error("persistScreenshot: actionId is required");
    if (!mimeType) throw new Error("persistScreenshot: mimeType is required");

    const sessionSegment = safePathSegment(sessionId);
    const actionSegment = safePathSegment(actionId);
    const ext = extensionForMimeType(mimeType);

    const sortKey =
      typeof relativeTimeMs === "number" && Number.isFinite(relativeTimeMs)
        ? String(Math.max(0, Math.floor(relativeTimeMs))).padStart(10, "0")
        : String(Math.max(0, Math.floor(wallClockCapturedAt))).padStart(13, "0");

    const filename = `${sortKey}_${actionSegment}_${phase}.${ext}`;
    const screenshotId = `${actionSegment}-${phase}-${wallClockCapturedAt}`;

    const baseDir = app.getPath("userData");
    const screenshotDir = path.join(baseDir, "sessions", sessionSegment, "screenshots");
    const filePath = path.join(screenshotDir, filename);

    const data = new Uint8Array(bytes);
    await writeFileAtomic(filePath, data);

    return {
      screenshotId,
      screenshotRef: `screenshots/${filename}`,
      filePath,
    };
  },
);

// Input capture IPC handlers
ipcMain.handle(
  "startInputCapture",
  async (_event, sessionId: string, sessionStartTime: number) => {
    try {
      await inputService.start(
        sessionId,
        sessionStartTime,
        (action: Action) => {
          // Forward action to renderer
          if (mainWindow && !mainWindow.isDestroyed()) {
            mainWindow.webContents.send("action", action);
          }
        },
      );
      return { success: true as const };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      console.error("Failed to start input capture:", message);
      return { success: false as const, error: message };
    }
  },
);

ipcMain.handle("stopInputCapture", () => {
  inputService.stop();
  return { success: true };
});

// Permission check for accessibility (required for global input capture on macOS)
ipcMain.handle("checkAccessibilityPermission", () => {
  if (process.platform === "darwin") {
    try {
      const permissions: AccessibilityPermissionsResult =
        iohookMacos.checkAccessibilityPermissions();
      return {
        granted: permissions.hasPermissions,
        platform: "darwin",
        message: permissions.message,
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return { granted: false, platform: "darwin", message };
    }
  }
  // On other platforms, assume permission is granted
  return { granted: true, platform: process.platform };
});
