import {
  app,
  BrowserWindow,
  desktopCapturer,
  dialog,
  ipcMain,
  screen,
} from "electron";
import { inputService } from "./main/inputService";
import iohookMacos from "iohook-macos";
import { Action } from "./main/types";
import type { AccessibilityPermissionsResult } from "iohook-macos";
import { promises as fs } from "fs";
import path from "path";
import { spawn } from "child_process";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const TOOLBAR_WINDOW_WEBPACK_ENTRY: string;
declare const TOOLBAR_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

// Store window references for IPC
let mainWindow: BrowserWindow | null = null;
let toolbarWindow: BrowserWindow | null = null;

// Toolbar dimensions
const TOOLBAR_WIDTH = 320;
const TOOLBAR_HEIGHT = 48; // Height for just the control buttons
const TOOLBAR_MARGIN_BOTTOM = 24;
// Per row of previews (16:9 thumbnail ~80px + label ~16px + gap)
const PICKER_ROW_HEIGHT = 100;
const PICKER_PADDING = 24; // padding around picker

const createMainWindow = (): void => {
  // Create the browser window - hidden by default, shown during recording
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    show: false, // Hidden by default
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools only in development
  // mainWindow.webContents.openDevTools();

  // Clean up reference when window is closed
  mainWindow.on("closed", () => {
    mainWindow = null;
    // Close toolbar when main window closes
    if (toolbarWindow && !toolbarWindow.isDestroyed()) {
      toolbarWindow.close();
    }
  });
};

const createToolbarWindow = (): void => {
  // Get primary display dimensions
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width: screenWidth, height: screenHeight } =
    primaryDisplay.workAreaSize;

  // Calculate position: bottom center of screen
  const x = Math.round((screenWidth - TOOLBAR_WIDTH) / 2);
  const y = screenHeight - TOOLBAR_HEIGHT - TOOLBAR_MARGIN_BOTTOM;

  toolbarWindow = new BrowserWindow({
    width: TOOLBAR_WIDTH,
    height: TOOLBAR_HEIGHT,
    x,
    y,
    frame: false,
    transparent: false,
    alwaysOnTop: true,
    resizable: false,
    skipTaskbar: true,
    hasShadow: true,
    focusable: true,
    roundedCorners: true,
    // macOS native blur effect
    vibrancy: "popover",
    visualEffectState: "active",
    webPreferences: {
      preload: TOOLBAR_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  toolbarWindow.loadURL(TOOLBAR_WINDOW_WEBPACK_ENTRY);

  // macOS: Set window level to floating and visible on all workspaces
  if (process.platform === "darwin") {
    toolbarWindow.setAlwaysOnTop(true, "floating");
    toolbarWindow.setVisibleOnAllWorkspaces(true, {
      visibleOnFullScreen: true,
    });
  }

  toolbarWindow.on("closed", () => {
    toolbarWindow = null;
  });
};

// Helper to calculate picker height based on source count
function calculatePickerHeight(numSources: number): number {
  const rows = Math.ceil(numSources / 2);
  return TOOLBAR_HEIGHT + PICKER_PADDING + rows * PICKER_ROW_HEIGHT;
}

// Helper to update toolbar size based on state
function updateToolbarSize(
  options: {
    isRecording?: boolean;
    pickerOpen?: boolean;
    numSources?: number;
  } = {},
) {
  if (!toolbarWindow || toolbarWindow.isDestroyed()) return;

  const isRecording = options.isRecording ?? false;
  const isPickerOpen = options.pickerOpen ?? false;
  const sourceCount = options.numSources ?? 0;

  const newWidth = isRecording ? 200 : TOOLBAR_WIDTH;
  const newHeight =
    isPickerOpen && !isRecording
      ? calculatePickerHeight(sourceCount)
      : TOOLBAR_HEIGHT;

  const primaryDisplay = screen.getPrimaryDisplay();
  const { width: screenWidth, height: screenHeight } =
    primaryDisplay.workAreaSize;
  const x = Math.round((screenWidth - newWidth) / 2);
  const y = screenHeight - newHeight - TOOLBAR_MARGIN_BOTTOM;

  toolbarWindow.setBounds({ x, y, width: newWidth, height: newHeight });
}

// Helper to broadcast state to toolbar
function broadcastToToolbar(channel: string, payload: unknown) {
  if (toolbarWindow && !toolbarWindow.isDestroyed()) {
    toolbarWindow.webContents.send(channel, payload);
  }
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", () => {
  createMainWindow();
  createToolbarWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createMainWindow();
    createToolbarWindow();
  }
});

// ============================================
// Toolbar <-> Main Window IPC Bridge
// ============================================

// Toolbar -> Main: Select a source
ipcMain.on("toolbar:selectSource", (_event, sourceId: string) => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send("toolbar:selectSource", sourceId);
  }
});

// Toolbar -> Main: Picker state changed (resize window)
ipcMain.on(
  "toolbar:pickerStateChanged",
  (_event, pickerOpen: boolean, numSources: number) => {
    updateToolbarSize({ pickerOpen, numSources });
  },
);

// Toolbar -> Main: Start recording
ipcMain.on("toolbar:start", () => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send("toolbar:start");
    // Keep main window hidden - recording controlled via toolbar
  }
  updateToolbarSize({ isRecording: true, pickerOpen: false });
  broadcastToToolbar("toolbar:stateUpdate", { state: "recording" });
});

// Toolbar -> Main: Stop recording
ipcMain.on("toolbar:stop", () => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send("toolbar:stop");
    // Optional: hide main window after stopping
    // mainWindow.hide();
  }
  updateToolbarSize({ isRecording: false });
  broadcastToToolbar("toolbar:stateUpdate", { state: "idle" });
});

// Toolbar -> Main: Pause recording
ipcMain.on("toolbar:pause", () => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send("toolbar:pause");
  }
  broadcastToToolbar("toolbar:stateUpdate", { state: "paused" });
});

// Toolbar -> Main: Resume recording
ipcMain.on("toolbar:resume", () => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send("toolbar:resume");
  }
  broadcastToToolbar("toolbar:stateUpdate", { state: "recording" });
});

// Main -> Toolbar: State update (called from main window renderer)
ipcMain.on(
  "main:stateUpdate",
  (
    _event,
    payload: {
      state?: "idle" | "recording" | "paused";
      selectedSourceId?: string;
      sources?: Electron.DesktopCapturerSource[];
    },
  ) => {
    broadcastToToolbar("toolbar:stateUpdate", payload);
    if (payload.state === "recording") {
      updateToolbarSize({ isRecording: true });
    } else if (payload.state === "idle") {
      updateToolbarSize({ isRecording: false });
    }
  },
);

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
ipcMain.handle("getSources", async () => {
  return await desktopCapturer.getSources({
    types: ["screen"],
    thumbnailSize: { width: 320, height: 180 }, // 16:9 aspect ratio thumbnails
  });
});

ipcMain.handle("showSaveDialog", async () => {
  return await dialog.showSaveDialog({
    buttonLabel: "Save video",
    defaultPath: `vid-${Date.now()}.webm`,
  });
});

ipcMain.handle("showSaveExportDialog", async (_event, defaultName?: string) => {
  return await dialog.showSaveDialog({
    buttonLabel: "Save export",
    defaultPath: defaultName || `session-${Date.now()}.zip`,
    filters: [{ name: "Zip", extensions: ["zip"] }],
  });
});

ipcMain.handle("getOperatingSystem", () => {
  return process.platform;
});

type PersistScreenshotPayload = {
  sessionId: string;
  actionId: string;
  phase: "before" | "during" | "after";
  mimeType: string;
  wallClockCapturedAt: number;
  streamTimestampMs?: number;
  captureLatencyMs?: number;
  relativeTimeMs?: number;
  bytes: ArrayBuffer;
};

type PersistScreenshotResult = {
  screenshotId: string;
  screenshotRef: string;
  filePath: string;
};

function safePathSegment(value: string) {
  return value.replace(/[^a-zA-Z0-9._-]+/g, "_");
}

function extensionForMimeType(mimeType: string) {
  switch (mimeType) {
    case "image/webp":
      return "webp";
    case "image/png":
      return "png";
    default:
      return "bin";
  }
}

async function writeFileAtomic(filePath: string, data: Uint8Array) {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
  const tempPath = `${filePath}.tmp-${process.pid}-${Date.now()}`;
  await fs.writeFile(tempPath, data);
  await fs.rename(tempPath, filePath);
}

type PersistVideoPayload = {
  sessionId: string;
  mimeType: string;
  wallClockCapturedAt: number;
  bytes: ArrayBuffer;
};

type PersistVideoResult = {
  videoRef: string;
  filePath: string;
  mimeType: string;
};

function extensionForVideoMimeType(mimeType: string) {
  if (mimeType.includes("webm")) return "webm";
  if (mimeType.includes("mp4")) return "mp4";
  return "bin";
}

ipcMain.handle(
  "persistVideo",
  async (_event, payload: PersistVideoPayload): Promise<PersistVideoResult> => {
    const { sessionId, mimeType, wallClockCapturedAt, bytes } = payload;
    if (!sessionId) throw new Error("persistVideo: sessionId is required");
    if (!mimeType) throw new Error("persistVideo: mimeType is required");

    const sessionSegment = safePathSegment(sessionId);
    const ext = extensionForVideoMimeType(mimeType);
    const filename = `recording-${wallClockCapturedAt}.${ext}`;

    const baseDir = app.getPath("userData");
    const videoDir = path.join(baseDir, "sessions", sessionSegment, "video");
    const filePath = path.join(videoDir, filename);

    const data = new Uint8Array(bytes);
    await writeFileAtomic(filePath, data);

    return {
      videoRef: `video/${filename}`,
      filePath,
      mimeType,
    };
  },
);

type ScreenshotExportMeta = {
  screenshotId: string;
  screenshotRef: string;
  actionId: string;
  phase: "before" | "during" | "after";
  mimeType: string;
  width: number;
  height: number;
  wallClockCapturedAt: number;
  streamTimestampMs?: number;
  captureLatencyMs: number;
};

type ExportSessionBundlePayload = {
  sessionId: string;
  createdAt: number;
  endedAt: number;
  actions: Action[];
  screenshots: ScreenshotExportMeta[];
  video: {
    videoRef: string;
    mimeType: string;
  };
  zipPath: string;
};

function runZip(cwd: string, zipPath: string, args: string[]) {
  return new Promise<void>((resolve, reject) => {
    const child = spawn("zip", ["-r", zipPath, ...args], { cwd });
    let stderr = "";
    child.stderr.on("data", (chunk) => {
      stderr += String(chunk);
    });
    child.on("error", (err) => reject(err));
    child.on("close", (code) => {
      if (code === 0) resolve();
      else reject(new Error(stderr || `zip exited with code ${code}`));
    });
  });
}

ipcMain.handle(
  "exportSessionBundle",
  async (
    _event,
    payload: ExportSessionBundlePayload,
  ): Promise<{ zipPath: string }> => {
    const { sessionId, zipPath } = payload;
    if (!sessionId)
      throw new Error("exportSessionBundle: sessionId is required");
    if (!zipPath) throw new Error("exportSessionBundle: zipPath is required");

    const sessionSegment = safePathSegment(sessionId);
    const baseDir = app.getPath("userData");
    const sessionDir = path.join(baseDir, "sessions", sessionSegment);

    await fs.mkdir(path.join(sessionDir, "screenshots"), { recursive: true });
    await fs.mkdir(path.join(sessionDir, "video"), { recursive: true });

    const actionsPath = path.join(sessionDir, "actions.json");
    await fs.mkdir(sessionDir, { recursive: true });
    await fs.writeFile(actionsPath, JSON.stringify(payload, null, 2), "utf8");

    await runZip(sessionDir, zipPath, ["actions.json", "video", "screenshots"]);
    return { zipPath };
  },
);

ipcMain.handle(
  "persistScreenshot",
  async (
    _event,
    payload: PersistScreenshotPayload,
  ): Promise<PersistScreenshotResult> => {
    const {
      sessionId,
      actionId,
      phase,
      mimeType,
      wallClockCapturedAt,
      relativeTimeMs,
      bytes,
    } = payload;

    if (!sessionId) throw new Error("persistScreenshot: sessionId is required");
    if (!actionId) throw new Error("persistScreenshot: actionId is required");
    if (!mimeType) throw new Error("persistScreenshot: mimeType is required");

    const sessionSegment = safePathSegment(sessionId);
    const actionSegment = safePathSegment(actionId);
    const ext = extensionForMimeType(mimeType);

    const sortKey =
      typeof relativeTimeMs === "number" && Number.isFinite(relativeTimeMs)
        ? String(Math.max(0, Math.floor(relativeTimeMs))).padStart(10, "0")
        : String(Math.max(0, Math.floor(wallClockCapturedAt))).padStart(
            13,
            "0",
          );

    const filename = `${sortKey}_${actionSegment}_${phase}.${ext}`;
    const screenshotId = `${actionSegment}-${phase}-${wallClockCapturedAt}`;

    const baseDir = app.getPath("userData");
    const screenshotDir = path.join(
      baseDir,
      "sessions",
      sessionSegment,
      "screenshots",
    );
    const filePath = path.join(screenshotDir, filename);

    const data = new Uint8Array(bytes);
    await writeFileAtomic(filePath, data);

    return {
      screenshotId,
      screenshotRef: `screenshots/${filename}`,
      filePath,
    };
  },
);

// Input capture IPC handlers
ipcMain.handle(
  "startInputCapture",
  async (_event, sessionId: string, sessionStartTime: number) => {
    try {
      await inputService.start(
        sessionId,
        sessionStartTime,
        (action: Action) => {
          // Forward action to renderer
          if (mainWindow && !mainWindow.isDestroyed()) {
            mainWindow.webContents.send("action", action);
          }
        },
      );
      return { success: true as const };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      console.error("Failed to start input capture:", message);
      return { success: false as const, error: message };
    }
  },
);

ipcMain.handle("stopInputCapture", () => {
  inputService.stop();
  return { success: true };
});

// Permission check for accessibility (required for global input capture on macOS)
ipcMain.handle("checkAccessibilityPermission", () => {
  if (process.platform === "darwin") {
    try {
      const permissions: AccessibilityPermissionsResult =
        iohookMacos.checkAccessibilityPermissions();
      return {
        granted: permissions.hasPermissions,
        platform: "darwin",
        message: permissions.message,
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return { granted: false, platform: "darwin", message };
    }
  }
  // On other platforms, assume permission is granted
  return { granted: true, platform: process.platform };
});
