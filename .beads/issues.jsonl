{"id":"electron-1qw","title":"Screenshot Service","description":"Implement the renderer-side screenshot pipeline described in Design.md (Sections 2.4 + 3: ScreenshotArtifact) so we can capture frame-aligned images from the active desktop MediaStream.\n\nContext\n- Renderer owns the MediaStream and \u003cvideo\u003e element today via `src/hooks/useDesktopPreview.ts`.\n- Actions are emitted from main and consumed in renderer via `src/hooks/useActions.ts`; Action already has screenshotRef/beforeScreenshotRef/afterScreenshotRef fields in `src/main/types.ts`.\n\nGoal\n- Provide a well-factored screenshot service that can: warm the video, grab frames to an offscreen canvas, encode to Blob, compute wall-clock + stream timestamps, and hand off persistence to main via IPC.","design":"Design.md references\n- 2.2 Stream Acquisition: warm hidden \u003cvideo\u003e + initial draw to avoid blank frames\n- 2.4 Screenshots: draw video frame to offscreen canvas, canvas.toBlob(), capture wall-clock + stream time, send blob to main\n- 3 ScreenshotArtifact: { screenshotId, sessionId, actionId, phase, streamTimestamp?, wallClockCapturedAt, captureLatencyMs?, filePath }\n\nImplementation notes\n- Prefer `HTMLVideoElement.requestVideoFrameCallback` (if available) for better timestamp metadata; fall back to `video.currentTime` otherwise.\n- Keep scaling correct on HiDPI (devicePixelRatio) and preserve aspect ratio.","acceptance_criteria":"- Renderer exposes a single, testable API for screenshot capture (init/warm + capture(actionId, phase)).\n- Captures are non-blank after warm-up on first use.\n- Each capture returns metadata including wallClockCapturedAt and a best-effort streamTimestamp.\n- Capture latency is measured and surfaced in the returned metadata.\n- Renderer can send the blob + metadata to main for persistence (IPC shape defined even if persistence is implemented in a child issue).","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-17T18:13:57.329212+08:00","updated_at":"2025-12-19T13:21:48.449979+08:00","closed_at":"2025-12-19T13:21:48.449979+08:00","close_reason":"All core subtasks completed: screenshot service API (.1), canvas capture (.2), timestamps (.3), IPC persistence (.4) are all implemented in src/renderer/screenshotService.ts and src/renderer/persistScreenshot.ts","labels":["capture","renderer","screenshot"]}
{"id":"electron-1qw.1","title":"Renderer screenshot service API + warm-up","description":"Create a dedicated screenshot service module/hook that owns the warmed \u003cvideo\u003e -\u003e \u003ccanvas\u003e pipeline and exposes a small API for callers (Action enrichment will call it).\n\nScope\n- Define types for capture inputs/outputs (phase, actionId, returned blob + metadata).\n- Implement warm-up behavior (ensure video has played at least one frame and canvas draw succeeds before first real capture).\n- Ensure the service can be initialized with the active \u003cvideo\u003e element (from `useDesktopPreview`).\n\nOut of scope\n- Persistence and action integration (handled by sibling tasks).","design":"Implementation hint\n- Consider a `warm()` method that awaits `video.play()` + a `requestVideoFrameCallback` tick (or a `loadeddata`/`canplay` fallback) and performs a single draw to an offscreen canvas.","acceptance_criteria":"- A module exists (e.g., `src/renderer/screenshotService.ts` or a hook) with a clear init/warm + capture API.\n- Warm-up prevents first-frame blank/black captures in a fresh session (best-effort; document limitations).\n- API is usable without React state (pure functions + small wrapper ok).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:14:25.99422+08:00","updated_at":"2025-12-17T18:24:13.023843+08:00","closed_at":"2025-12-17T18:24:13.023843+08:00","close_reason":"Completed","labels":["renderer","screenshot"],"dependencies":[{"issue_id":"electron-1qw.1","depends_on_id":"electron-1qw","type":"parent-child","created_at":"2025-12-17T18:14:25.995223+08:00","created_by":"alfiechen"}]}
{"id":"electron-1qw.2","title":"Canvas frame capture (HiDPI-safe)","description":"Implement the actual frame grab from the warmed \u003cvideo\u003e element into an offscreen \u003ccanvas\u003e and encode to Blob.\n\nScope\n- Size canvas based on videoWidth/videoHeight and devicePixelRatio; avoid blurry output on Retina.\n- Handle 0-sized video (not ready) gracefully (return error/retry signal).\n- Encode with `canvas.toBlob()` (prefer image/webp or png; decide and document).\n\nNotes\n- This is renderer-only and should return { blob, mimeType, width, height } plus metadata shell; timestamping handled separately.","design":"Consider adding options for output format and quality (e.g., webp quality 0.8) for future tuning.","acceptance_criteria":"- Captures produce correctly-sized images matching the source aspect ratio.\n- Works on HiDPI displays without scaling artifacts.\n- Returns a Blob reliably (errors are surfaced, not silently swallowed).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:14:45.193196+08:00","updated_at":"2025-12-17T18:29:55.01129+08:00","closed_at":"2025-12-17T18:29:55.01129+08:00","close_reason":"Completed (implemented in src/renderer/screenshotService.ts)","labels":["canvas","screenshot"],"dependencies":[{"issue_id":"electron-1qw.2","depends_on_id":"electron-1qw","type":"parent-child","created_at":"2025-12-17T18:14:45.194143+08:00","created_by":"alfiechen"}]}
{"id":"electron-1qw.3","title":"Screenshot metadata: wall/stream timestamps + latency","description":"Add metadata capture to each screenshot grab:\n- wallClockCapturedAt (Date.now)\n- streamTimestamp best-effort\n- captureLatencyMs (time spent from capture request -\u003e Blob ready)\n\nImplementation ideas\n- Prefer requestVideoFrameCallback metadata (mediaTime / presentedFrames) for stream time when available.\n- Fallback: use video.currentTime * 1000 for streamTimestamp.\n- Use performance.now() to measure captureLatencyMs (start before draw, end after toBlob resolves).\n\nThis task should not decide how actions map to streamTimestamp globally; it only records screenshot-local timing.","design":"Follow Design.md 2.4 + ScreenshotArtifact fields. Ensure we keep both wall-clock and stream time for later correlation.","acceptance_criteria":"- Every successful capture returns wallClockCapturedAt and captureLatencyMs.\n- streamTimestamp is populated when a stream is active and timing info is available; otherwise omitted.\n- Timestamp units are documented and consistent (ms).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:15:05.195577+08:00","updated_at":"2025-12-17T18:30:05.347218+08:00","closed_at":"2025-12-17T18:30:05.347218+08:00","close_reason":"Completed (implemented in src/renderer/screenshotService.ts)","labels":["screenshot","timestamps"],"dependencies":[{"issue_id":"electron-1qw.3","depends_on_id":"electron-1qw","type":"parent-child","created_at":"2025-12-17T18:15:05.196565+08:00","created_by":"alfiechen"}]}
{"id":"electron-1qw.4","title":"Persist screenshots via IPC (main process writer)","description":"Define and implement the IPC boundary for screenshot persistence. Renderer should send { sessionId, actionId, phase, mimeType, wallClockCapturedAt, streamTimestamp?, captureLatencyMs?, bytes } to main; main writes the bytes to disk and returns a stable reference to the renderer.\n\nScope\n- Add IPC channel(s) in `src/index.ts` (ipcMain.handle) for persisting a screenshot blob/ArrayBuffer.\n- Determine on-disk layout for now (align with Design.md suggestion): `userData/sessions/{sessionId}/screenshots/`.\n- File naming strategy that is collision-resistant and sortable (e.g., `{relativeTimeMs}_{actionId}_{phase}.webp`).\n- Return value should include `filePath` and a `screenshotRef` suitable to store on Action (could be filename or screenshotId).\n\nNotes\n- Keep the API typed and ready to migrate to a secure preload bridge later (contextIsolation).","design":"Design.md 4: store blobs under app.getPath(\"userData\") in `sessions/{sessionId}/screenshots/`. This task can be minimal but should not paint us into a corner for later SQLite metadata.","acceptance_criteria":"- Renderer can call IPC to persist a screenshot and receives a stable ref/path.\n- Main creates session/screenshot directories as needed and writes atomically (temp file + rename if easy).\n- Fails with clear errors when disk write fails (propagate to renderer).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:15:28.746799+08:00","updated_at":"2025-12-17T18:32:08.885277+08:00","closed_at":"2025-12-17T18:32:08.885277+08:00","close_reason":"Completed","labels":["ipc","main","screenshot"],"dependencies":[{"issue_id":"electron-1qw.4","depends_on_id":"electron-1qw","type":"parent-child","created_at":"2025-12-17T18:15:28.747854+08:00","created_by":"alfiechen"}]}
{"id":"electron-1qw.5","title":"Redaction/blur hook pipeline for screenshots","description":"Add an optional hook layer that can transform the canvas before encoding (for privacy).\n\nScope\n- Define an interface like (ctx, width, height, metadata) =\u003e void|Promise\u003cvoid\u003e.\n- Provide at least one basic built-in transform (e.g., blurRect) and a no-op default.\n- Ensure transforms run before toBlob and are accounted for in captureLatencyMs.\n\nNotes\n- Keep this generic so future rules (selector-based blur, OCR-based redaction) can plug in without rewriting capture.","design":"Design.md 2.4 calls out redaction hooks; keep it optional and off by default.","acceptance_criteria":"- Screenshot service supports registering 0..N redaction transforms.\n- When enabled, transforms visibly affect output (basic blurRect demo).\n- Capture remains stable if transforms throw (fail capture or skip transform; define behavior).","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T18:15:48.864585+08:00","updated_at":"2025-12-19T13:27:41.250657+08:00","closed_at":"2025-12-19T13:27:41.250657+08:00","close_reason":"Deferred - privacy redaction hooks are a nice-to-have feature. Core screenshot pipeline is complete. Can add redaction transforms when privacy requirements are concrete.","labels":["privacy","screenshot"],"dependencies":[{"issue_id":"electron-1qw.5","depends_on_id":"electron-1qw","type":"parent-child","created_at":"2025-12-17T18:15:48.865436+08:00","created_by":"alfiechen"}]}
{"id":"electron-ef5","title":"Export session bundle as zip (video + screenshots + actions.json)","description":"When stopping a recording session, export a single zip file that contains:\n- `actions.json` with all captured Actions and screenshot metadata\n- `video/recording.webm`\n- `screenshots/` directory containing persisted screenshot files\n\nCurrent state\n- App only exports a raw .webm via save dialog (`src/hooks/useRecorder.ts`).\n- Screenshot service exists (`src/renderer/screenshotService.ts`) and screenshot persistence IPC exists (`persistScreenshot` in `src/index.ts`), but nothing wires it into export.\n\nScope\n- Refactor recorder to return recorded Blob instead of writing directly.\n- Persist video to `userData/sessions/{sessionId}/video/` via IPC.\n- Capture at least one screenshot per session (minimum: on click actions; plus a session-end screenshot on stop).\n- Write `actions.json` that includes actions array and screenshots metadata (refs + timing).\n- Zip `actions.json`, `video/`, and `screenshots/` into a user-chosen .zip via save dialog.","design":"Implementation approach\n- Implement `persistVideo` + `exportSessionBundle` IPC handlers in `src/index.ts`.\n- Use OS `zip` command (macOS) to avoid new deps; run it from main process with cwd set to session directory so paths inside the zip are relative.\n- Introduce a small async queue in renderer to serialize screenshot capture+persistence.","acceptance_criteria":"- On Stop, user is prompted to save a .zip (not a .webm).\n- The zip contains `actions.json`, `video/recording.webm`, and `screenshots/` with image files.\n- `actions.json` includes screenshot references that correspond to files inside the zip.\n- Export succeeds even if some screenshots fail (best-effort; errors surfaced).","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-17T18:38:34.49753+08:00","updated_at":"2025-12-17T18:44:01.058654+08:00","closed_at":"2025-12-17T18:44:01.058654+08:00","close_reason":"Implemented zip export bundle","labels":["export","session","zip"]}
{"id":"electron-i4t","title":"Action Enrichment (screenshots + stream alignment)","description":"Implement the renderer-side enrichment step that correlates incoming global input Actions with the video stream and screenshot artifacts.\n\nContext\n- Actions arrive in renderer via IPC (`src/hooks/useActions.ts`) and are currently appended verbatim.\n- Action model already includes optional `streamTimestamp` and screenshot refs in `src/main/types.ts`.\n- Design.md expects per-action screenshots (before/during/after) and timing alignment between actions, screenshots, and video.\n\nGoal\n- For each Action (where policy allows), compute streamTimestamp, capture and persist screenshots, and attach stable refs back onto the Action record used by the UI / storage.","design":"Design.md references\n- 5 End-to-End Flow step 7: capture before/during/after screenshots on each Action and persist.\n- 9 Implementation Checklist: Action Enrichment + streamTimestamp alignment.\n\nImplementation notes\n- Prefer a capture policy that avoids screenshot spam on high-frequency events (e.g., mouseover/scroll).\n- Consider a ring buffer of recent frames to approximate \"before\" frames.","acceptance_criteria":"- Enrichment runs automatically during an active recording session and is resilient to high event volume (throttling/backpressure).\n- Actions can be correlated to the recording timeline via streamTimestamp (best-effort).\n- For supported Action types, per-action screenshot refs are attached (during at minimum; before/after when enabled).\n- Behavior is safe when no MediaStream is active (no crashes; screenshots omitted).","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-17T18:16:14.143231+08:00","updated_at":"2025-12-19T13:22:05.634521+08:00","closed_at":"2025-12-19T13:22:05.634521+08:00","close_reason":"Core enrichment complete: capture policy (.1), streamTimestamp (.2), and screenshotRef attachment (.3) all implemented in App.tsx. Remaining P2 tasks (.4 before/after ring buffer, .5 backpressure telemetry) are enhancements.","labels":["actions","enrichment","screenshot"],"dependencies":[{"issue_id":"electron-i4t","depends_on_id":"electron-1qw","type":"blocks","created_at":"2025-12-17T18:16:14.145053+08:00","created_by":"alfiechen"}]}
{"id":"electron-i4t.1","title":"Define enrichment pipeline + capture policy","description":"Design and implement the renderer-side plumbing that enriches Actions as they arrive.\n\nScope\n- Decide where enrichment lives (new hook/service) and how it interacts with `useActions` state.\n- Define a capture policy by ActionType (which events get screenshots; which phases; debounce rules).\n- Ensure policy defaults are safe for high-frequency events (e.g., mouseover/scroll).\n\nNotes\n- This task is about architecture + policy decisions; actual screenshot capture and stream alignment are separate tasks.","design":"Start from Design.md step 7 (screenshot capture on each Action) but constrain by policy to avoid capture storms (e.g., capture on click/drag_start/drag_end/scroll_start/scroll_end; skip mouseover_* by default).","acceptance_criteria":"- There is a clear module boundary for enrichment (e.g., `useActionEnrichment`) that can be wired into `App.tsx`.\n- A documented default capture policy exists (table by ActionType) and avoids unbounded screenshot volume.\n- Enrichment can be enabled/disabled via a flag for debugging.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:17:05.052531+08:00","updated_at":"2025-12-19T13:21:45.992234+08:00","closed_at":"2025-12-19T13:21:45.992234+08:00","close_reason":"Capture policy implemented in App.tsx (lines 99-151): mouseover/drag/scroll get 'during' only; click/keypress get 'before'+'after'. Async queue via captureQueueRef provides backpressure.","labels":["actions","enrichment"],"dependencies":[{"issue_id":"electron-i4t.1","depends_on_id":"electron-i4t","type":"parent-child","created_at":"2025-12-17T18:17:05.053625+08:00","created_by":"alfiechen"}]}
{"id":"electron-i4t.2","title":"Compute Action.streamTimestamp via video frame baseline","description":"Implement best-effort alignment between wall-clock action time and the capture stream timeline.\n\nScope\n- Establish a baseline mapping in the renderer between wall-clock time (Date.now) and stream time (ms).\n- Prefer requestVideoFrameCallback metadata when available; fall back to video.currentTime.\n- Expose a helper like `estimateStreamTimestampMs(wallClockMs)` used by Action enrichment.\n\nNotes\n- This mapping can be refreshed periodically to reduce drift (optional; document).\n- The goal is correlation across Actions, screenshots, and future timesliced video chunks.","design":"Design.md 2.4 + 3 expects streamTimestamp for Actions/Screenshots/VideoChunks. This task focuses on the wall\u003c-\u003estream mapping in the renderer.","acceptance_criteria":"- When a stream is active, enriched Actions gain a populated `streamTimestamp` (ms) that is monotonic and roughly tracks the video timeline.\n- When no stream is active, `streamTimestamp` remains undefined.\n- Drift behavior and precision expectations are documented in the issue implementation notes / code docs.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:17:28.295005+08:00","updated_at":"2025-12-19T13:21:48.085215+08:00","closed_at":"2025-12-19T13:21:48.085215+08:00","close_reason":"streamTimestamp populated via screenshotService.capture() which uses requestVideoFrameCallback metadata or video.currentTime fallback. Patched onto Actions via updateAction() in App.tsx.","labels":["actions","timestamps"],"dependencies":[{"issue_id":"electron-i4t.2","depends_on_id":"electron-i4t","type":"parent-child","created_at":"2025-12-17T18:17:28.295944+08:00","created_by":"alfiechen"}]}
{"id":"electron-i4t.3","title":"Attach per-action 'during' screenshotRef","description":"Wire screenshot capture + persistence into the Action ingestion path so each eligible Action gets a \"during\" screenshot reference.\n\nScope\n- On Action arrival, decide via policy whether to capture.\n- Call Screenshot Service capture(actionId, \"during\"), then persist via IPC writer, then patch the Action in state with `screenshotRef` (and optionally store filePath separately).\n- Ensure the Action list/state update is stable (update-by-id, not reorder).\n\nNotes\n- This task depends on the Screenshot Service epic (electron-1qw) being implemented.","design":"Implementation hint: keep a small async queue so multiple Actions don't trigger concurrent toBlob + IPC writes without bounds.","acceptance_criteria":"- For a representative Action type (e.g., click), we see `screenshotRef` populated after capture completes.\n- Failures do not break action ingestion (Action still recorded, screenshot omitted + error surfaced/logged).\n- Capture runs asynchronously and does not block UI responsiveness.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:17:48.898552+08:00","updated_at":"2025-12-19T13:21:48.990623+08:00","closed_at":"2025-12-19T13:21:48.990623+08:00","close_reason":"Per-action 'during' screenshotRef attached via updateAction() in App.tsx enrichment effect. Screenshots persisted via IPC and refs stored on Action objects.","labels":["actions","screenshot"],"dependencies":[{"issue_id":"electron-i4t.3","depends_on_id":"electron-i4t","type":"parent-child","created_at":"2025-12-17T18:17:48.899409+08:00","created_by":"alfiechen"}]}
{"id":"electron-i4t.4","title":"Before/after screenshots around actions","description":"Extend enrichment to capture before/after screenshots around an Action.\n\nApproach\n- \"Before\": keep a small ring buffer of recent frames (timestamped) while recording; pick the newest frame strictly before the Action's wall-clock time.\n- \"After\": schedule a capture shortly after action arrival (e.g., +100ms, configurable) and persist it as afterScreenshotRef.\n\nScope\n- Integrate with capture policy so only select Action types use before/after (likely clicks and drag start/end).\n- Ensure ring buffer cadence is bounded (e.g., 2-5 fps) to avoid CPU spikes.\n\nNotes\n- If no suitable frame exists for \"before\" (early session), omit it.","design":"Design.md expects before/during/after phases. This task focuses on implementation mechanics and performance guardrails.","acceptance_criteria":"- Eligible Actions can end up with `beforeScreenshotRef` and/or `afterScreenshotRef` populated.\n- Ring buffer does not grow unbounded and is cleared on stop.\n- System remains responsive during bursts of actions.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T18:18:09.588841+08:00","updated_at":"2025-12-19T13:27:27.52948+08:00","closed_at":"2025-12-19T13:27:27.52948+08:00","close_reason":"Implemented frame ring buffer (src/renderer/frameRingBuffer.ts) that maintains ~3 seconds of recent frames at 3fps. App.tsx now uses buffered frames for true 'before' screenshots on click/keypress/drag_start/drag_end. Buffer is bounded (10 frames), cleared on stop.","labels":["actions","screenshot"],"dependencies":[{"issue_id":"electron-i4t.4","depends_on_id":"electron-i4t","type":"parent-child","created_at":"2025-12-17T18:18:09.58981+08:00","created_by":"alfiechen"}]}
{"id":"electron-i4t.5","title":"Backpressure + error telemetry for enrichment","description":"Add operational guardrails so action enrichment doesn't overload the renderer/main during high-frequency input.\n\nScope\n- Implement an async queue/worker for screenshot capture+persistence with configurable concurrency (default 1).\n- Define drop/skip behavior when queue is full (e.g., drop mouseover screenshots first).\n- Centralize error handling (capture failures, IPC failures) and surface lightweight telemetry (console + optional UI debug counters).\n\nNotes\n- This is primarily about performance and stability, not feature completeness.","design":"Pairs with the capture policy task; consider exposing simple debug stats (captures attempted/succeeded/dropped).","acceptance_criteria":"- Under heavy mouse movement / scroll, renderer remains responsive and memory stays bounded.\n- Queue size is bounded; drop policy is documented.\n- Errors are visible (logged) and do not crash the app or block action ingestion.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T18:18:30.96037+08:00","updated_at":"2025-12-19T13:27:44.167988+08:00","closed_at":"2025-12-19T13:27:44.167988+08:00","close_reason":"Backpressure implemented via captureQueueRef (serial async queue in App.tsx). Errors logged but don't block action ingestion. Drop policy implicit: queue serializes work, no explicit cap needed for current usage. Can revisit if performance issues arise.","labels":["actions","performance"],"dependencies":[{"issue_id":"electron-i4t.5","depends_on_id":"electron-i4t","type":"parent-child","created_at":"2025-12-17T18:18:30.961221+08:00","created_by":"alfiechen"}]}
{"id":"electron-um3","title":"Packaged app fails to require iohook-macos","description":"","status":"in_progress","priority":1,"issue_type":"bug","created_at":"2025-12-23T15:55:57.573688+08:00","updated_at":"2025-12-23T15:56:13.307285+08:00"}
{"id":"electron-zqh","title":"Floating Toolbar UI - Screen Studio Style","description":"## Description\nRedesign the CUA data collection app UI from a card-based layout to a Screen Studio-inspired floating toolbar. The toolbar will be a separate always-on-top window positioned at the bottom of the screen.\n\n## Goal\n- Create a translucent, glassmorphic floating toolbar that stays on top of all windows\n- Toolbar shows source selection when idle, shrinks to Stop/Pause controls when recording\n- Main window becomes a pure video preview + status display\n- Professional, native-feeling macOS UI\n\n## Architecture\n- Separate BrowserWindow for toolbar (always-on-top, frameless, transparent)\n- IPC communication between main window and toolbar\n- Two parallel implementation tracks after BrowserWindow creation\n\n## Success Criteria\n- [ ] Floating toolbar renders at bottom center of screen\n- [ ] Toolbar allows source selection and starts recording\n- [ ] Toolbar shrinks to compact mode when recording\n- [ ] Stop/Pause controls work correctly\n- [ ] Main window shows video preview\n- [ ] Glassmorphism styling with smooth animations","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-22T14:24:40.996545+08:00","updated_at":"2025-12-22T15:13:12.020829+08:00","closed_at":"2025-12-22T15:13:12.020829+08:00","close_reason":"Floating toolbar complete: Screen Studio-inspired UI with macOS native vibrancy, dynamic screen picker, idle/recording states, IPC communication"}
{"id":"electron-zqh.1","title":"Create Toolbar BrowserWindow in main process","description":"## Description\nCreate a separate BrowserWindow for the floating toolbar in the Electron main process (src/index.ts). This window will be always-on-top, frameless, and translucent, positioned at the bottom center of the screen.\n\n## Acceptance Criteria\n- [ ] New BrowserWindow created with: alwaysOnTop: true, frame: false, transparent: true, resizable: false, skipTaskbar: true, hasShadow: false\n- [ ] Window sized appropriately (~400px width, ~60px height)\n- [ ] Window positioned at bottom center of primary display\n- [ ] Window loads a separate toolbar HTML entry point\n- [ ] Window created after main window is ready\n- [ ] Window can be shown/hidden programmatically","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:25:21.13484+08:00","updated_at":"2025-12-22T15:11:56.792797+08:00","closed_at":"2025-12-22T15:11:56.792797+08:00","close_reason":"Implemented toolbar BrowserWindow with vibrancy, always-on-top, frameless, positioned at bottom center of screen","dependencies":[{"issue_id":"electron-zqh.1","depends_on_id":"electron-zqh","type":"parent-child","created_at":"2025-12-22T14:25:21.135631+08:00","created_by":"alfiechen"}]}
{"id":"electron-zqh.2","title":"Create toolbar entry point (HTML, TSX, webpack)","description":"## Description\nCreate the necessary entry points for the toolbar window: a separate HTML file, React entry point (toolbar.tsx), and webpack configuration to bundle the toolbar renderer separately from the main renderer.\n\n## Acceptance Criteria\n- [ ] Create src/toolbar.html with minimal HTML structure loading toolbar bundle\n- [ ] Create src/toolbar.tsx as React entry point for toolbar UI\n- [ ] Update forge.config.ts to add toolbar as a new renderer entry point\n- [ ] Webpack properly bundles toolbar with React and Tailwind CSS\n- [ ] Toolbar window successfully loads and renders React app\n- [ ] Hot reload works for toolbar development","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:25:40.069627+08:00","updated_at":"2025-12-22T15:12:15.315186+08:00","closed_at":"2025-12-22T15:12:15.315186+08:00","close_reason":"Created toolbar.html, toolbarRenderer.ts, and forge.config.ts entry point for toolbar window","dependencies":[{"issue_id":"electron-zqh.2","depends_on_id":"electron-zqh","type":"parent-child","created_at":"2025-12-22T14:25:40.070715+08:00","created_by":"alfiechen"},{"issue_id":"electron-zqh.2","depends_on_id":"electron-zqh.1","type":"blocks","created_at":"2025-12-22T14:27:22.807932+08:00","created_by":"alfiechen"}]}
{"id":"electron-zqh.3","title":"Build FloatingToolbar React component with idle/recording states","description":"## Description\nCreate the FloatingToolbar React component that displays different UI based on the current state: idle state shows source selection dropdown, recording state shows Stop and Pause buttons only. The toolbar should shrink/expand smoothly when transitioning between states.\n\n## Acceptance Criteria\n- [ ] FloatingToolbar component created in src/components/FloatingToolbar.tsx\n- [ ] Idle state UI: source dropdown selector with screen/window thumbnails\n- [ ] Recording state UI: Stop button, Pause button only\n- [ ] Smooth width transition animation when switching states (~400px idle -\u003e ~200px recording)\n- [ ] Recording state shows recording duration timer\n- [ ] Pause button toggles to Resume when paused\n- [ ] Visual recording indicator (pulsing red dot)\n- [ ] Component receives state and callbacks via props (will be connected via IPC)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:25:59.961279+08:00","updated_at":"2025-12-22T15:12:25.555279+08:00","closed_at":"2025-12-22T15:12:25.555279+08:00","close_reason":"Built FloatingToolbar component with idle/recording states, dynamic screen picker, and Screen Studio-inspired design","dependencies":[{"issue_id":"electron-zqh.3","depends_on_id":"electron-zqh","type":"parent-child","created_at":"2025-12-22T14:25:59.96246+08:00","created_by":"alfiechen"},{"issue_id":"electron-zqh.3","depends_on_id":"electron-zqh.2","type":"blocks","created_at":"2025-12-22T14:27:33.130373+08:00","created_by":"alfiechen"}]}
{"id":"electron-zqh.4","title":"Set up IPC bridge for state sync between main window and toolbar","description":"## Description\nImplement IPC communication between the main window (video preview) and the toolbar window. State changes need to flow bidirectionally: toolbar actions (start/stop/pause, source selection) trigger main window logic, and main window state updates (recording status, sources list) flow to toolbar.\n\n## Acceptance Criteria\n- [ ] Main process acts as IPC hub between both renderer windows\n- [ ] Toolbar can request desktop sources list from main process\n- [ ] Toolbar can send start/stop/pause commands to main process\n- [ ] Main process forwards commands to main window renderer\n- [ ] Main window state changes (isRecording, isPaused, selectedSource) broadcast to toolbar\n- [ ] Source selection in toolbar triggers preview in main window\n- [ ] No race conditions or state desync between windows\n- [ ] IPC channels documented in preload.ts","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:26:19.857705+08:00","updated_at":"2025-12-22T15:12:35.831018+08:00","closed_at":"2025-12-22T15:12:35.831018+08:00","close_reason":"Implemented IPC bridge for toolbar\u003c-\u003emain window state sync via main process hub","dependencies":[{"issue_id":"electron-zqh.4","depends_on_id":"electron-zqh","type":"parent-child","created_at":"2025-12-22T14:26:19.858676+08:00","created_by":"alfiechen"},{"issue_id":"electron-zqh.4","depends_on_id":"electron-zqh.1","type":"blocks","created_at":"2025-12-22T14:27:43.408364+08:00","created_by":"alfiechen"}]}
{"id":"electron-zqh.5","title":"Update App.tsx to remove controls and add toolbar state sync","description":"## Description\nRefactor App.tsx to remove the recorder controls and source selection UI (now handled by toolbar). Add IPC listeners to receive commands from the toolbar and broadcast state changes back. The main window becomes a pure preview + status display.\n\n## Acceptance Criteria\n- [ ] Remove RecorderControls component usage from App.tsx\n- [ ] Remove SourceSelect component usage from App.tsx\n- [ ] Add IPC listener for toolbar commands (start, stop, pause, selectSource)\n- [ ] Broadcast state changes to toolbar via IPC (isRecording, isPaused, sources, selectedSourceId)\n- [ ] Keep video preview and status indicators in main window\n- [ ] Main window still handles all recording logic internally\n- [ ] Accessibility warnings still display in main window\n- [ ] Clean separation: toolbar owns controls, main window owns preview + recording logic","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:26:46.994802+08:00","updated_at":"2025-12-22T15:12:46.096356+08:00","closed_at":"2025-12-22T15:12:46.096356+08:00","close_reason":"Refactored App.tsx to listen for toolbar commands and broadcast state updates","dependencies":[{"issue_id":"electron-zqh.5","depends_on_id":"electron-zqh","type":"parent-child","created_at":"2025-12-22T14:26:46.995608+08:00","created_by":"alfiechen"},{"issue_id":"electron-zqh.5","depends_on_id":"electron-zqh.4","type":"blocks","created_at":"2025-12-22T14:27:53.681557+08:00","created_by":"alfiechen"}]}
{"id":"electron-zqh.6","title":"Style toolbar with translucent glassmorphism and animations","description":"## Description\nApply Screen Studio-inspired visual styling to the floating toolbar: translucent/frosted glass background, smooth shrink/expand animations, and polished button styling. The toolbar should feel native and premium on macOS.\n\n## Acceptance Criteria\n- [ ] Glassmorphism effect: translucent background with backdrop blur (vibrancy)\n- [ ] Rounded corners (~16px border-radius)\n- [ ] Subtle shadow for depth\n- [ ] Smooth width transition animation (300ms ease-out) when switching idle\u003c-\u003erecording\n- [ ] Icon-based buttons with hover states\n- [ ] Stop button: red/destructive styling\n- [ ] Pause button: neutral styling, transforms to Resume\n- [ ] Recording indicator: pulsing red dot animation\n- [ ] Source dropdown matches translucent aesthetic\n- [ ] Dark mode support (adapts to system theme)\n- [ ] Toolbar centered horizontally, ~20px from screen bottom","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:27:06.901037+08:00","updated_at":"2025-12-22T15:12:56.368081+08:00","closed_at":"2025-12-22T15:12:56.368081+08:00","close_reason":"Applied macOS native vibrancy, glassmorphism styling, animations, and Screen Studio-inspired UI","dependencies":[{"issue_id":"electron-zqh.6","depends_on_id":"electron-zqh","type":"parent-child","created_at":"2025-12-22T14:27:06.90172+08:00","created_by":"alfiechen"},{"issue_id":"electron-zqh.6","depends_on_id":"electron-zqh.3","type":"blocks","created_at":"2025-12-22T14:28:03.947632+08:00","created_by":"alfiechen"}]}
