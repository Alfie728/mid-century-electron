{"id":"electron-1qw","title":"Screenshot Service","description":"Implement the renderer-side screenshot pipeline described in Design.md (Sections 2.4 + 3: ScreenshotArtifact) so we can capture frame-aligned images from the active desktop MediaStream.\n\nContext\n- Renderer owns the MediaStream and \u003cvideo\u003e element today via `src/hooks/useDesktopPreview.ts`.\n- Actions are emitted from main and consumed in renderer via `src/hooks/useActions.ts`; Action already has screenshotRef/beforeScreenshotRef/afterScreenshotRef fields in `src/main/types.ts`.\n\nGoal\n- Provide a well-factored screenshot service that can: warm the video, grab frames to an offscreen canvas, encode to Blob, compute wall-clock + stream timestamps, and hand off persistence to main via IPC.","design":"Design.md references\n- 2.2 Stream Acquisition: warm hidden \u003cvideo\u003e + initial draw to avoid blank frames\n- 2.4 Screenshots: draw video frame to offscreen canvas, canvas.toBlob(), capture wall-clock + stream time, send blob to main\n- 3 ScreenshotArtifact: { screenshotId, sessionId, actionId, phase, streamTimestamp?, wallClockCapturedAt, captureLatencyMs?, filePath }\n\nImplementation notes\n- Prefer `HTMLVideoElement.requestVideoFrameCallback` (if available) for better timestamp metadata; fall back to `video.currentTime` otherwise.\n- Keep scaling correct on HiDPI (devicePixelRatio) and preserve aspect ratio.","acceptance_criteria":"- Renderer exposes a single, testable API for screenshot capture (init/warm + capture(actionId, phase)).\n- Captures are non-blank after warm-up on first use.\n- Each capture returns metadata including wallClockCapturedAt and a best-effort streamTimestamp.\n- Capture latency is measured and surfaced in the returned metadata.\n- Renderer can send the blob + metadata to main for persistence (IPC shape defined even if persistence is implemented in a child issue).","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-17T18:13:57.329212+08:00","updated_at":"2025-12-17T18:13:57.329212+08:00","labels":["capture","renderer","screenshot"]}
{"id":"electron-1qw.1","title":"Renderer screenshot service API + warm-up","description":"Create a dedicated screenshot service module/hook that owns the warmed \u003cvideo\u003e -\u003e \u003ccanvas\u003e pipeline and exposes a small API for callers (Action enrichment will call it).\n\nScope\n- Define types for capture inputs/outputs (phase, actionId, returned blob + metadata).\n- Implement warm-up behavior (ensure video has played at least one frame and canvas draw succeeds before first real capture).\n- Ensure the service can be initialized with the active \u003cvideo\u003e element (from `useDesktopPreview`).\n\nOut of scope\n- Persistence and action integration (handled by sibling tasks).","design":"Implementation hint\n- Consider a `warm()` method that awaits `video.play()` + a `requestVideoFrameCallback` tick (or a `loadeddata`/`canplay` fallback) and performs a single draw to an offscreen canvas.","acceptance_criteria":"- A module exists (e.g., `src/renderer/screenshotService.ts` or a hook) with a clear init/warm + capture API.\n- Warm-up prevents first-frame blank/black captures in a fresh session (best-effort; document limitations).\n- API is usable without React state (pure functions + small wrapper ok).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:14:25.99422+08:00","updated_at":"2025-12-17T18:24:13.023843+08:00","closed_at":"2025-12-17T18:24:13.023843+08:00","close_reason":"Completed","labels":["renderer","screenshot"],"dependencies":[{"issue_id":"electron-1qw.1","depends_on_id":"electron-1qw","type":"parent-child","created_at":"2025-12-17T18:14:25.995223+08:00","created_by":"alfiechen"}]}
{"id":"electron-1qw.2","title":"Canvas frame capture (HiDPI-safe)","description":"Implement the actual frame grab from the warmed \u003cvideo\u003e element into an offscreen \u003ccanvas\u003e and encode to Blob.\n\nScope\n- Size canvas based on videoWidth/videoHeight and devicePixelRatio; avoid blurry output on Retina.\n- Handle 0-sized video (not ready) gracefully (return error/retry signal).\n- Encode with `canvas.toBlob()` (prefer image/webp or png; decide and document).\n\nNotes\n- This is renderer-only and should return { blob, mimeType, width, height } plus metadata shell; timestamping handled separately.","design":"Consider adding options for output format and quality (e.g., webp quality 0.8) for future tuning.","acceptance_criteria":"- Captures produce correctly-sized images matching the source aspect ratio.\n- Works on HiDPI displays without scaling artifacts.\n- Returns a Blob reliably (errors are surfaced, not silently swallowed).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:14:45.193196+08:00","updated_at":"2025-12-17T18:29:55.01129+08:00","closed_at":"2025-12-17T18:29:55.01129+08:00","close_reason":"Completed (implemented in src/renderer/screenshotService.ts)","labels":["canvas","screenshot"],"dependencies":[{"issue_id":"electron-1qw.2","depends_on_id":"electron-1qw","type":"parent-child","created_at":"2025-12-17T18:14:45.194143+08:00","created_by":"alfiechen"}]}
{"id":"electron-1qw.3","title":"Screenshot metadata: wall/stream timestamps + latency","description":"Add metadata capture to each screenshot grab:\n- wallClockCapturedAt (Date.now)\n- streamTimestamp best-effort\n- captureLatencyMs (time spent from capture request -\u003e Blob ready)\n\nImplementation ideas\n- Prefer requestVideoFrameCallback metadata (mediaTime / presentedFrames) for stream time when available.\n- Fallback: use video.currentTime * 1000 for streamTimestamp.\n- Use performance.now() to measure captureLatencyMs (start before draw, end after toBlob resolves).\n\nThis task should not decide how actions map to streamTimestamp globally; it only records screenshot-local timing.","design":"Follow Design.md 2.4 + ScreenshotArtifact fields. Ensure we keep both wall-clock and stream time for later correlation.","acceptance_criteria":"- Every successful capture returns wallClockCapturedAt and captureLatencyMs.\n- streamTimestamp is populated when a stream is active and timing info is available; otherwise omitted.\n- Timestamp units are documented and consistent (ms).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:15:05.195577+08:00","updated_at":"2025-12-17T18:30:05.347218+08:00","closed_at":"2025-12-17T18:30:05.347218+08:00","close_reason":"Completed (implemented in src/renderer/screenshotService.ts)","labels":["screenshot","timestamps"],"dependencies":[{"issue_id":"electron-1qw.3","depends_on_id":"electron-1qw","type":"parent-child","created_at":"2025-12-17T18:15:05.196565+08:00","created_by":"alfiechen"}]}
{"id":"electron-1qw.4","title":"Persist screenshots via IPC (main process writer)","description":"Define and implement the IPC boundary for screenshot persistence. Renderer should send { sessionId, actionId, phase, mimeType, wallClockCapturedAt, streamTimestamp?, captureLatencyMs?, bytes } to main; main writes the bytes to disk and returns a stable reference to the renderer.\n\nScope\n- Add IPC channel(s) in `src/index.ts` (ipcMain.handle) for persisting a screenshot blob/ArrayBuffer.\n- Determine on-disk layout for now (align with Design.md suggestion): `userData/sessions/{sessionId}/screenshots/`.\n- File naming strategy that is collision-resistant and sortable (e.g., `{relativeTimeMs}_{actionId}_{phase}.webp`).\n- Return value should include `filePath` and a `screenshotRef` suitable to store on Action (could be filename or screenshotId).\n\nNotes\n- Keep the API typed and ready to migrate to a secure preload bridge later (contextIsolation).","design":"Design.md 4: store blobs under app.getPath(\"userData\") in `sessions/{sessionId}/screenshots/`. This task can be minimal but should not paint us into a corner for later SQLite metadata.","acceptance_criteria":"- Renderer can call IPC to persist a screenshot and receives a stable ref/path.\n- Main creates session/screenshot directories as needed and writes atomically (temp file + rename if easy).\n- Fails with clear errors when disk write fails (propagate to renderer).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T18:15:28.746799+08:00","updated_at":"2025-12-17T18:32:08.885277+08:00","closed_at":"2025-12-17T18:32:08.885277+08:00","close_reason":"Completed","labels":["ipc","main","screenshot"],"dependencies":[{"issue_id":"electron-1qw.4","depends_on_id":"electron-1qw","type":"parent-child","created_at":"2025-12-17T18:15:28.747854+08:00","created_by":"alfiechen"}]}
{"id":"electron-1qw.5","title":"Redaction/blur hook pipeline for screenshots","description":"Add an optional hook layer that can transform the canvas before encoding (for privacy).\n\nScope\n- Define an interface like (ctx, width, height, metadata) =\u003e void|Promise\u003cvoid\u003e.\n- Provide at least one basic built-in transform (e.g., blurRect) and a no-op default.\n- Ensure transforms run before toBlob and are accounted for in captureLatencyMs.\n\nNotes\n- Keep this generic so future rules (selector-based blur, OCR-based redaction) can plug in without rewriting capture.","design":"Design.md 2.4 calls out redaction hooks; keep it optional and off by default.","acceptance_criteria":"- Screenshot service supports registering 0..N redaction transforms.\n- When enabled, transforms visibly affect output (basic blurRect demo).\n- Capture remains stable if transforms throw (fail capture or skip transform; define behavior).","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T18:15:48.864585+08:00","updated_at":"2025-12-17T18:15:48.864585+08:00","labels":["privacy","screenshot"],"dependencies":[{"issue_id":"electron-1qw.5","depends_on_id":"electron-1qw","type":"parent-child","created_at":"2025-12-17T18:15:48.865436+08:00","created_by":"alfiechen"}]}
{"id":"electron-ef5","title":"Export session bundle as zip (video + screenshots + actions.json)","description":"When stopping a recording session, export a single zip file that contains:\n- `actions.json` with all captured Actions and screenshot metadata\n- `video/recording.webm`\n- `screenshots/` directory containing persisted screenshot files\n\nCurrent state\n- App only exports a raw .webm via save dialog (`src/hooks/useRecorder.ts`).\n- Screenshot service exists (`src/renderer/screenshotService.ts`) and screenshot persistence IPC exists (`persistScreenshot` in `src/index.ts`), but nothing wires it into export.\n\nScope\n- Refactor recorder to return recorded Blob instead of writing directly.\n- Persist video to `userData/sessions/{sessionId}/video/` via IPC.\n- Capture at least one screenshot per session (minimum: on click actions; plus a session-end screenshot on stop).\n- Write `actions.json` that includes actions array and screenshots metadata (refs + timing).\n- Zip `actions.json`, `video/`, and `screenshots/` into a user-chosen .zip via save dialog.","design":"Implementation approach\n- Implement `persistVideo` + `exportSessionBundle` IPC handlers in `src/index.ts`.\n- Use OS `zip` command (macOS) to avoid new deps; run it from main process with cwd set to session directory so paths inside the zip are relative.\n- Introduce a small async queue in renderer to serialize screenshot capture+persistence.","acceptance_criteria":"- On Stop, user is prompted to save a .zip (not a .webm).\n- The zip contains `actions.json`, `video/recording.webm`, and `screenshots/` with image files.\n- `actions.json` includes screenshot references that correspond to files inside the zip.\n- Export succeeds even if some screenshots fail (best-effort; errors surfaced).","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-17T18:38:34.49753+08:00","updated_at":"2025-12-17T18:44:01.058654+08:00","closed_at":"2025-12-17T18:44:01.058654+08:00","close_reason":"Implemented zip export bundle","labels":["export","session","zip"]}
{"id":"electron-i4t","title":"Action Enrichment (screenshots + stream alignment)","description":"Implement the renderer-side enrichment step that correlates incoming global input Actions with the video stream and screenshot artifacts.\n\nContext\n- Actions arrive in renderer via IPC (`src/hooks/useActions.ts`) and are currently appended verbatim.\n- Action model already includes optional `streamTimestamp` and screenshot refs in `src/main/types.ts`.\n- Design.md expects per-action screenshots (before/during/after) and timing alignment between actions, screenshots, and video.\n\nGoal\n- For each Action (where policy allows), compute streamTimestamp, capture and persist screenshots, and attach stable refs back onto the Action record used by the UI / storage.","design":"Design.md references\n- 5 End-to-End Flow step 7: capture before/during/after screenshots on each Action and persist.\n- 9 Implementation Checklist: Action Enrichment + streamTimestamp alignment.\n\nImplementation notes\n- Prefer a capture policy that avoids screenshot spam on high-frequency events (e.g., mouseover/scroll).\n- Consider a ring buffer of recent frames to approximate \"before\" frames.","acceptance_criteria":"- Enrichment runs automatically during an active recording session and is resilient to high event volume (throttling/backpressure).\n- Actions can be correlated to the recording timeline via streamTimestamp (best-effort).\n- For supported Action types, per-action screenshot refs are attached (during at minimum; before/after when enabled).\n- Behavior is safe when no MediaStream is active (no crashes; screenshots omitted).","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-17T18:16:14.143231+08:00","updated_at":"2025-12-17T18:16:14.143231+08:00","labels":["actions","enrichment","screenshot"],"dependencies":[{"issue_id":"electron-i4t","depends_on_id":"electron-1qw","type":"blocks","created_at":"2025-12-17T18:16:14.145053+08:00","created_by":"alfiechen"}]}
{"id":"electron-i4t.1","title":"Define enrichment pipeline + capture policy","description":"Design and implement the renderer-side plumbing that enriches Actions as they arrive.\n\nScope\n- Decide where enrichment lives (new hook/service) and how it interacts with `useActions` state.\n- Define a capture policy by ActionType (which events get screenshots; which phases; debounce rules).\n- Ensure policy defaults are safe for high-frequency events (e.g., mouseover/scroll).\n\nNotes\n- This task is about architecture + policy decisions; actual screenshot capture and stream alignment are separate tasks.","design":"Start from Design.md step 7 (screenshot capture on each Action) but constrain by policy to avoid capture storms (e.g., capture on click/drag_start/drag_end/scroll_start/scroll_end; skip mouseover_* by default).","acceptance_criteria":"- There is a clear module boundary for enrichment (e.g., `useActionEnrichment`) that can be wired into `App.tsx`.\n- A documented default capture policy exists (table by ActionType) and avoids unbounded screenshot volume.\n- Enrichment can be enabled/disabled via a flag for debugging.","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-17T18:17:05.052531+08:00","updated_at":"2025-12-17T19:10:50.111836+08:00","labels":["actions","enrichment"],"dependencies":[{"issue_id":"electron-i4t.1","depends_on_id":"electron-i4t","type":"parent-child","created_at":"2025-12-17T18:17:05.053625+08:00","created_by":"alfiechen"}]}
{"id":"electron-i4t.2","title":"Compute Action.streamTimestamp via video frame baseline","description":"Implement best-effort alignment between wall-clock action time and the capture stream timeline.\n\nScope\n- Establish a baseline mapping in the renderer between wall-clock time (Date.now) and stream time (ms).\n- Prefer requestVideoFrameCallback metadata when available; fall back to video.currentTime.\n- Expose a helper like `estimateStreamTimestampMs(wallClockMs)` used by Action enrichment.\n\nNotes\n- This mapping can be refreshed periodically to reduce drift (optional; document).\n- The goal is correlation across Actions, screenshots, and future timesliced video chunks.","design":"Design.md 2.4 + 3 expects streamTimestamp for Actions/Screenshots/VideoChunks. This task focuses on the wall\u003c-\u003estream mapping in the renderer.","acceptance_criteria":"- When a stream is active, enriched Actions gain a populated `streamTimestamp` (ms) that is monotonic and roughly tracks the video timeline.\n- When no stream is active, `streamTimestamp` remains undefined.\n- Drift behavior and precision expectations are documented in the issue implementation notes / code docs.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T18:17:28.295005+08:00","updated_at":"2025-12-17T18:17:28.295005+08:00","labels":["actions","timestamps"],"dependencies":[{"issue_id":"electron-i4t.2","depends_on_id":"electron-i4t","type":"parent-child","created_at":"2025-12-17T18:17:28.295944+08:00","created_by":"alfiechen"}]}
{"id":"electron-i4t.3","title":"Attach per-action 'during' screenshotRef","description":"Wire screenshot capture + persistence into the Action ingestion path so each eligible Action gets a \"during\" screenshot reference.\n\nScope\n- On Action arrival, decide via policy whether to capture.\n- Call Screenshot Service capture(actionId, \"during\"), then persist via IPC writer, then patch the Action in state with `screenshotRef` (and optionally store filePath separately).\n- Ensure the Action list/state update is stable (update-by-id, not reorder).\n\nNotes\n- This task depends on the Screenshot Service epic (electron-1qw) being implemented.","design":"Implementation hint: keep a small async queue so multiple Actions don't trigger concurrent toBlob + IPC writes without bounds.","acceptance_criteria":"- For a representative Action type (e.g., click), we see `screenshotRef` populated after capture completes.\n- Failures do not break action ingestion (Action still recorded, screenshot omitted + error surfaced/logged).\n- Capture runs asynchronously and does not block UI responsiveness.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T18:17:48.898552+08:00","updated_at":"2025-12-17T18:17:48.898552+08:00","labels":["actions","screenshot"],"dependencies":[{"issue_id":"electron-i4t.3","depends_on_id":"electron-i4t","type":"parent-child","created_at":"2025-12-17T18:17:48.899409+08:00","created_by":"alfiechen"}]}
{"id":"electron-i4t.4","title":"Before/after screenshots around actions","description":"Extend enrichment to capture before/after screenshots around an Action.\n\nApproach\n- \"Before\": keep a small ring buffer of recent frames (timestamped) while recording; pick the newest frame strictly before the Action's wall-clock time.\n- \"After\": schedule a capture shortly after action arrival (e.g., +100ms, configurable) and persist it as afterScreenshotRef.\n\nScope\n- Integrate with capture policy so only select Action types use before/after (likely clicks and drag start/end).\n- Ensure ring buffer cadence is bounded (e.g., 2-5 fps) to avoid CPU spikes.\n\nNotes\n- If no suitable frame exists for \"before\" (early session), omit it.","design":"Design.md expects before/during/after phases. This task focuses on implementation mechanics and performance guardrails.","acceptance_criteria":"- Eligible Actions can end up with `beforeScreenshotRef` and/or `afterScreenshotRef` populated.\n- Ring buffer does not grow unbounded and is cleared on stop.\n- System remains responsive during bursts of actions.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T18:18:09.588841+08:00","updated_at":"2025-12-17T18:18:09.588841+08:00","labels":["actions","screenshot"],"dependencies":[{"issue_id":"electron-i4t.4","depends_on_id":"electron-i4t","type":"parent-child","created_at":"2025-12-17T18:18:09.58981+08:00","created_by":"alfiechen"}]}
{"id":"electron-i4t.5","title":"Backpressure + error telemetry for enrichment","description":"Add operational guardrails so action enrichment doesn't overload the renderer/main during high-frequency input.\n\nScope\n- Implement an async queue/worker for screenshot capture+persistence with configurable concurrency (default 1).\n- Define drop/skip behavior when queue is full (e.g., drop mouseover screenshots first).\n- Centralize error handling (capture failures, IPC failures) and surface lightweight telemetry (console + optional UI debug counters).\n\nNotes\n- This is primarily about performance and stability, not feature completeness.","design":"Pairs with the capture policy task; consider exposing simple debug stats (captures attempted/succeeded/dropped).","acceptance_criteria":"- Under heavy mouse movement / scroll, renderer remains responsive and memory stays bounded.\n- Queue size is bounded; drop policy is documented.\n- Errors are visible (logged) and do not crash the app or block action ingestion.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T18:18:30.96037+08:00","updated_at":"2025-12-17T18:18:30.96037+08:00","labels":["actions","performance"],"dependencies":[{"issue_id":"electron-i4t.5","depends_on_id":"electron-i4t","type":"parent-child","created_at":"2025-12-17T18:18:30.961221+08:00","created_by":"alfiechen"}]}
